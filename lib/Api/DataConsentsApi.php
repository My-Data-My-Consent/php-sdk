<?php
/**
 * DataConsentsApi
 * PHP version 7.3
 *
 * @category Class
 * @package  MyDataMyConsent
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * My Data My Consent - Developer API
 *
 * Unleashing the power of data consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@mydatamyconsent.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MyDataMyConsent\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MyDataMyConsent\ApiException;
use MyDataMyConsent\Configuration;
use MyDataMyConsent\HeaderSelector;
use MyDataMyConsent\ObjectSerializer;

/**
 * DataConsentsApi Class Doc Comment
 *
 * @category Class
 * @package  MyDataMyConsent
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DataConsentsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation downloadConsentedDocumentById
     *
     * Download a individuals consented document.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\UserDocumentDownloadDto|object
     */
    public function downloadConsentedDocumentById($consent_id, $document_id)
    {
        list($response) = $this->downloadConsentedDocumentByIdWithHttpInfo($consent_id, $document_id);
        return $response;
    }

    /**
     * Operation downloadConsentedDocumentByIdWithHttpInfo
     *
     * Download a individuals consented document.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\UserDocumentDownloadDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadConsentedDocumentByIdWithHttpInfo($consent_id, $document_id)
    {
        $request = $this->downloadConsentedDocumentByIdRequest($consent_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\UserDocumentDownloadDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\UserDocumentDownloadDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\UserDocumentDownloadDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\UserDocumentDownloadDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadConsentedDocumentByIdAsync
     *
     * Download a individuals consented document.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadConsentedDocumentByIdAsync($consent_id, $document_id)
    {
        return $this->downloadConsentedDocumentByIdAsyncWithHttpInfo($consent_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadConsentedDocumentByIdAsyncWithHttpInfo
     *
     * Download a individuals consented document.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadConsentedDocumentByIdAsyncWithHttpInfo($consent_id, $document_id)
    {
        $returnType = '\MyDataMyConsent\Model\UserDocumentDownloadDto';
        $request = $this->downloadConsentedDocumentByIdRequest($consent_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadConsentedDocumentById'
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadConsentedDocumentByIdRequest($consent_id, $document_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling downloadConsentedDocumentById'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling downloadConsentedDocumentById'
            );
        }

        $resourcePath = '/v1/consents/individuals/{consentId}/documents/{documentId}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation downloadOrgConsentedDocumentById
     *
     * Download a organizations consented document.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\OrganizationDocumentDownloadDto|object
     */
    public function downloadOrgConsentedDocumentById($consent_id, $document_id)
    {
        list($response) = $this->downloadOrgConsentedDocumentByIdWithHttpInfo($consent_id, $document_id);
        return $response;
    }

    /**
     * Operation downloadOrgConsentedDocumentByIdWithHttpInfo
     *
     * Download a organizations consented document.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\OrganizationDocumentDownloadDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function downloadOrgConsentedDocumentByIdWithHttpInfo($consent_id, $document_id)
    {
        $request = $this->downloadOrgConsentedDocumentByIdRequest($consent_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\OrganizationDocumentDownloadDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\OrganizationDocumentDownloadDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\OrganizationDocumentDownloadDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\OrganizationDocumentDownloadDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation downloadOrgConsentedDocumentByIdAsync
     *
     * Download a organizations consented document.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadOrgConsentedDocumentByIdAsync($consent_id, $document_id)
    {
        return $this->downloadOrgConsentedDocumentByIdAsyncWithHttpInfo($consent_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation downloadOrgConsentedDocumentByIdAsyncWithHttpInfo
     *
     * Download a organizations consented document.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function downloadOrgConsentedDocumentByIdAsyncWithHttpInfo($consent_id, $document_id)
    {
        $returnType = '\MyDataMyConsent\Model\OrganizationDocumentDownloadDto';
        $request = $this->downloadOrgConsentedDocumentByIdRequest($consent_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'downloadOrgConsentedDocumentById'
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function downloadOrgConsentedDocumentByIdRequest($consent_id, $document_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling downloadOrgConsentedDocumentById'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling downloadOrgConsentedDocumentById'
            );
        }

        $resourcePath = '/v1/consents/organizations/{consentId}/documents/{documentId}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllConsentedDocuments
     *
     * Get the individual documents based on ConsentId.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\DataConsentDocumentsDto|object
     */
    public function getAllConsentedDocuments($consent_id)
    {
        list($response) = $this->getAllConsentedDocumentsWithHttpInfo($consent_id);
        return $response;
    }

    /**
     * Operation getAllConsentedDocumentsWithHttpInfo
     *
     * Get the individual documents based on ConsentId.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\DataConsentDocumentsDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllConsentedDocumentsWithHttpInfo($consent_id)
    {
        $request = $this->getAllConsentedDocumentsRequest($consent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\DataConsentDocumentsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\DataConsentDocumentsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\DataConsentDocumentsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\DataConsentDocumentsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllConsentedDocumentsAsync
     *
     * Get the individual documents based on ConsentId.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllConsentedDocumentsAsync($consent_id)
    {
        return $this->getAllConsentedDocumentsAsyncWithHttpInfo($consent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllConsentedDocumentsAsyncWithHttpInfo
     *
     * Get the individual documents based on ConsentId.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllConsentedDocumentsAsyncWithHttpInfo($consent_id)
    {
        $returnType = '\MyDataMyConsent\Model\DataConsentDocumentsDto';
        $request = $this->getAllConsentedDocumentsRequest($consent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllConsentedDocuments'
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllConsentedDocumentsRequest($consent_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getAllConsentedDocuments'
            );
        }

        $resourcePath = '/v1/consents/individuals/{consentId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllConsentedFinancialAccounts
     *
     * Get all individual consented financial accounts.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\DataConsentFinancialsDto|object
     */
    public function getAllConsentedFinancialAccounts($consent_id)
    {
        list($response) = $this->getAllConsentedFinancialAccountsWithHttpInfo($consent_id);
        return $response;
    }

    /**
     * Operation getAllConsentedFinancialAccountsWithHttpInfo
     *
     * Get all individual consented financial accounts.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\DataConsentFinancialsDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllConsentedFinancialAccountsWithHttpInfo($consent_id)
    {
        $request = $this->getAllConsentedFinancialAccountsRequest($consent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\DataConsentFinancialsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\DataConsentFinancialsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\DataConsentFinancialsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\DataConsentFinancialsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllConsentedFinancialAccountsAsync
     *
     * Get all individual consented financial accounts.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllConsentedFinancialAccountsAsync($consent_id)
    {
        return $this->getAllConsentedFinancialAccountsAsyncWithHttpInfo($consent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllConsentedFinancialAccountsAsyncWithHttpInfo
     *
     * Get all individual consented financial accounts.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllConsentedFinancialAccountsAsyncWithHttpInfo($consent_id)
    {
        $returnType = '\MyDataMyConsent\Model\DataConsentFinancialsDto';
        $request = $this->getAllConsentedFinancialAccountsRequest($consent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllConsentedFinancialAccounts'
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllConsentedFinancialAccountsRequest($consent_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getAllConsentedFinancialAccounts'
            );
        }

        $resourcePath = '/v1/consents/individuals/{consentId}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllOrganizationConsentedDocuments
     *
     * Get the organization documents based on ConsentId.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\DataConsentDocumentsDto|object
     */
    public function getAllOrganizationConsentedDocuments($consent_id)
    {
        list($response) = $this->getAllOrganizationConsentedDocumentsWithHttpInfo($consent_id);
        return $response;
    }

    /**
     * Operation getAllOrganizationConsentedDocumentsWithHttpInfo
     *
     * Get the organization documents based on ConsentId.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\DataConsentDocumentsDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllOrganizationConsentedDocumentsWithHttpInfo($consent_id)
    {
        $request = $this->getAllOrganizationConsentedDocumentsRequest($consent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\DataConsentDocumentsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\DataConsentDocumentsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\DataConsentDocumentsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\DataConsentDocumentsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllOrganizationConsentedDocumentsAsync
     *
     * Get the organization documents based on ConsentId.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllOrganizationConsentedDocumentsAsync($consent_id)
    {
        return $this->getAllOrganizationConsentedDocumentsAsyncWithHttpInfo($consent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllOrganizationConsentedDocumentsAsyncWithHttpInfo
     *
     * Get the organization documents based on ConsentId.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllOrganizationConsentedDocumentsAsyncWithHttpInfo($consent_id)
    {
        $returnType = '\MyDataMyConsent\Model\DataConsentDocumentsDto';
        $request = $this->getAllOrganizationConsentedDocumentsRequest($consent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllOrganizationConsentedDocuments'
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllOrganizationConsentedDocumentsRequest($consent_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getAllOrganizationConsentedDocuments'
            );
        }

        $resourcePath = '/v1/consents/organizations/{consentId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentDetailsById
     *
     * Get all individuals consent details by consent id.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\DataConsentDetailsDto|object
     */
    public function getConsentDetailsById($consent_id)
    {
        list($response) = $this->getConsentDetailsByIdWithHttpInfo($consent_id);
        return $response;
    }

    /**
     * Operation getConsentDetailsByIdWithHttpInfo
     *
     * Get all individuals consent details by consent id.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\DataConsentDetailsDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentDetailsByIdWithHttpInfo($consent_id)
    {
        $request = $this->getConsentDetailsByIdRequest($consent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\DataConsentDetailsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\DataConsentDetailsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\DataConsentDetailsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\DataConsentDetailsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentDetailsByIdAsync
     *
     * Get all individuals consent details by consent id.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentDetailsByIdAsync($consent_id)
    {
        return $this->getConsentDetailsByIdAsyncWithHttpInfo($consent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentDetailsByIdAsyncWithHttpInfo
     *
     * Get all individuals consent details by consent id.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentDetailsByIdAsyncWithHttpInfo($consent_id)
    {
        $returnType = '\MyDataMyConsent\Model\DataConsentDetailsDto';
        $request = $this->getConsentDetailsByIdRequest($consent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentDetailsById'
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConsentDetailsByIdRequest($consent_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentDetailsById'
            );
        }

        $resourcePath = '/v1/consents/individuals/{consentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentFinancialAccounts
     *
     * Get all organizational consented financial accounts.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\DataConsentFinancialsDto|object
     */
    public function getConsentFinancialAccounts($consent_id)
    {
        list($response) = $this->getConsentFinancialAccountsWithHttpInfo($consent_id);
        return $response;
    }

    /**
     * Operation getConsentFinancialAccountsWithHttpInfo
     *
     * Get all organizational consented financial accounts.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\DataConsentFinancialsDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentFinancialAccountsWithHttpInfo($consent_id)
    {
        $request = $this->getConsentFinancialAccountsRequest($consent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\DataConsentFinancialsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\DataConsentFinancialsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\DataConsentFinancialsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\DataConsentFinancialsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentFinancialAccountsAsync
     *
     * Get all organizational consented financial accounts.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentFinancialAccountsAsync($consent_id)
    {
        return $this->getConsentFinancialAccountsAsyncWithHttpInfo($consent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentFinancialAccountsAsyncWithHttpInfo
     *
     * Get all organizational consented financial accounts.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentFinancialAccountsAsyncWithHttpInfo($consent_id)
    {
        $returnType = '\MyDataMyConsent\Model\DataConsentFinancialsDto';
        $request = $this->getConsentFinancialAccountsRequest($consent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentFinancialAccounts'
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConsentFinancialAccountsRequest($consent_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentFinancialAccounts'
            );
        }

        $resourcePath = '/v1/consents/organizations/{consentId}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentedAccountById
     *
     * Get individual consented financial account details based on account id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\FinancialAccount|object
     */
    public function getConsentedAccountById($consent_id, $account_id)
    {
        list($response) = $this->getConsentedAccountByIdWithHttpInfo($consent_id, $account_id);
        return $response;
    }

    /**
     * Operation getConsentedAccountByIdWithHttpInfo
     *
     * Get individual consented financial account details based on account id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\FinancialAccount|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentedAccountByIdWithHttpInfo($consent_id, $account_id)
    {
        $request = $this->getConsentedAccountByIdRequest($consent_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\FinancialAccount' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\FinancialAccount', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\FinancialAccount';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\FinancialAccount',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentedAccountByIdAsync
     *
     * Get individual consented financial account details based on account id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentedAccountByIdAsync($consent_id, $account_id)
    {
        return $this->getConsentedAccountByIdAsyncWithHttpInfo($consent_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentedAccountByIdAsyncWithHttpInfo
     *
     * Get individual consented financial account details based on account id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentedAccountByIdAsyncWithHttpInfo($consent_id, $account_id)
    {
        $returnType = '\MyDataMyConsent\Model\FinancialAccount';
        $request = $this->getConsentedAccountByIdRequest($consent_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentedAccountById'
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConsentedAccountByIdRequest($consent_id, $account_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentedAccountById'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getConsentedAccountById'
            );
        }

        $resourcePath = '/v1/consents/individuals/{consentId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentedDocumentById
     *
     * Get individuals consent document based on document id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\UserDocumentDetailsDto|object
     */
    public function getConsentedDocumentById($consent_id, $document_id)
    {
        list($response) = $this->getConsentedDocumentByIdWithHttpInfo($consent_id, $document_id);
        return $response;
    }

    /**
     * Operation getConsentedDocumentByIdWithHttpInfo
     *
     * Get individuals consent document based on document id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\UserDocumentDetailsDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentedDocumentByIdWithHttpInfo($consent_id, $document_id)
    {
        $request = $this->getConsentedDocumentByIdRequest($consent_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\UserDocumentDetailsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\UserDocumentDetailsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\UserDocumentDetailsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\UserDocumentDetailsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentedDocumentByIdAsync
     *
     * Get individuals consent document based on document id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentedDocumentByIdAsync($consent_id, $document_id)
    {
        return $this->getConsentedDocumentByIdAsyncWithHttpInfo($consent_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentedDocumentByIdAsyncWithHttpInfo
     *
     * Get individuals consent document based on document id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentedDocumentByIdAsyncWithHttpInfo($consent_id, $document_id)
    {
        $returnType = '\MyDataMyConsent\Model\UserDocumentDetailsDto';
        $request = $this->getConsentedDocumentByIdRequest($consent_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentedDocumentById'
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConsentedDocumentByIdRequest($consent_id, $document_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentedDocumentById'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getConsentedDocumentById'
            );
        }

        $resourcePath = '/v1/consents/individuals/{consentId}/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentedFinancialAccount
     *
     * Get organization consented financial account details based on account id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\OrganizationFinancialAccountDto|object
     */
    public function getConsentedFinancialAccount($consent_id, $account_id)
    {
        list($response) = $this->getConsentedFinancialAccountWithHttpInfo($consent_id, $account_id);
        return $response;
    }

    /**
     * Operation getConsentedFinancialAccountWithHttpInfo
     *
     * Get organization consented financial account details based on account id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\OrganizationFinancialAccountDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentedFinancialAccountWithHttpInfo($consent_id, $account_id)
    {
        $request = $this->getConsentedFinancialAccountRequest($consent_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\OrganizationFinancialAccountDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\OrganizationFinancialAccountDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\OrganizationFinancialAccountDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\OrganizationFinancialAccountDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentedFinancialAccountAsync
     *
     * Get organization consented financial account details based on account id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentedFinancialAccountAsync($consent_id, $account_id)
    {
        return $this->getConsentedFinancialAccountAsyncWithHttpInfo($consent_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentedFinancialAccountAsyncWithHttpInfo
     *
     * Get organization consented financial account details based on account id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentedFinancialAccountAsyncWithHttpInfo($consent_id, $account_id)
    {
        $returnType = '\MyDataMyConsent\Model\OrganizationFinancialAccountDto';
        $request = $this->getConsentedFinancialAccountRequest($consent_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentedFinancialAccount'
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConsentedFinancialAccountRequest($consent_id, $account_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentedFinancialAccount'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getConsentedFinancialAccount'
            );
        }

        $resourcePath = '/v1/consents/organizations/{consentId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentedFinancialAccountTransactions
     *
     * Get individual consented financial account transactions of an individual based on accountId.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 10)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\UserAccountFinancialTransactionsDtoPaginatedList|object
     */
    public function getConsentedFinancialAccountTransactions($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 10, $page_size = 25)
    {
        list($response) = $this->getConsentedFinancialAccountTransactionsWithHttpInfo($consent_id, $account_id, $filters, $from_date_time_utc, $to_date_time_utc, $page_no, $page_size);
        return $response;
    }

    /**
     * Operation getConsentedFinancialAccountTransactionsWithHttpInfo
     *
     * Get individual consented financial account transactions of an individual based on accountId.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 10)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\UserAccountFinancialTransactionsDtoPaginatedList|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentedFinancialAccountTransactionsWithHttpInfo($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 10, $page_size = 25)
    {
        $request = $this->getConsentedFinancialAccountTransactionsRequest($consent_id, $account_id, $filters, $from_date_time_utc, $to_date_time_utc, $page_no, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\UserAccountFinancialTransactionsDtoPaginatedList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\UserAccountFinancialTransactionsDtoPaginatedList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\UserAccountFinancialTransactionsDtoPaginatedList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\UserAccountFinancialTransactionsDtoPaginatedList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentedFinancialAccountTransactionsAsync
     *
     * Get individual consented financial account transactions of an individual based on accountId.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 10)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentedFinancialAccountTransactionsAsync($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 10, $page_size = 25)
    {
        return $this->getConsentedFinancialAccountTransactionsAsyncWithHttpInfo($consent_id, $account_id, $filters, $from_date_time_utc, $to_date_time_utc, $page_no, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentedFinancialAccountTransactionsAsyncWithHttpInfo
     *
     * Get individual consented financial account transactions of an individual based on accountId.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 10)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentedFinancialAccountTransactionsAsyncWithHttpInfo($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 10, $page_size = 25)
    {
        $returnType = '\MyDataMyConsent\Model\UserAccountFinancialTransactionsDtoPaginatedList';
        $request = $this->getConsentedFinancialAccountTransactionsRequest($consent_id, $account_id, $filters, $from_date_time_utc, $to_date_time_utc, $page_no, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentedFinancialAccountTransactions'
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 10)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConsentedFinancialAccountTransactionsRequest($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 10, $page_size = 25)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getConsentedFinancialAccountTransactions'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getConsentedFinancialAccountTransactions'
            );
        }

        $resourcePath = '/v1/consents/individuals/{consentId}/accounts/{accountId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filters !== null) {
            if('form' === 'form' && is_array($filters)) {
                foreach($filters as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filters'] = $filters;
            }
        }
        // query params
        if ($from_date_time_utc !== null) {
            if('form' === 'form' && is_array($from_date_time_utc)) {
                foreach($from_date_time_utc as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fromDateTimeUtc'] = $from_date_time_utc;
            }
        }
        // query params
        if ($to_date_time_utc !== null) {
            if('form' === 'form' && is_array($to_date_time_utc)) {
                foreach($to_date_time_utc as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['toDateTimeUtc'] = $to_date_time_utc;
            }
        }
        // query params
        if ($page_no !== null) {
            if('form' === 'form' && is_array($page_no)) {
                foreach($page_no as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pageNo'] = $page_no;
            }
        }
        // query params
        if ($page_size !== null) {
            if('form' === 'form' && is_array($page_size)) {
                foreach($page_size as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pageSize'] = $page_size;
            }
        }


        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentsForOrganizations
     *
     * Get the list of data consents sent for organizations.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\OrganizationDataConsentInfoDtoPaginatedList|object
     */
    public function getConsentsForOrganizations($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {
        list($response) = $this->getConsentsForOrganizationsWithHttpInfo($status, $from, $to, $page_no, $page_size);
        return $response;
    }

    /**
     * Operation getConsentsForOrganizationsWithHttpInfo
     *
     * Get the list of data consents sent for organizations.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\OrganizationDataConsentInfoDtoPaginatedList|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentsForOrganizationsWithHttpInfo($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {
        $request = $this->getConsentsForOrganizationsRequest($status, $from, $to, $page_no, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\OrganizationDataConsentInfoDtoPaginatedList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\OrganizationDataConsentInfoDtoPaginatedList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\OrganizationDataConsentInfoDtoPaginatedList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\OrganizationDataConsentInfoDtoPaginatedList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentsForOrganizationsAsync
     *
     * Get the list of data consents sent for organizations.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentsForOrganizationsAsync($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {
        return $this->getConsentsForOrganizationsAsyncWithHttpInfo($status, $from, $to, $page_no, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentsForOrganizationsAsyncWithHttpInfo
     *
     * Get the list of data consents sent for organizations.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentsForOrganizationsAsyncWithHttpInfo($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {
        $returnType = '\MyDataMyConsent\Model\OrganizationDataConsentInfoDtoPaginatedList';
        $request = $this->getConsentsForOrganizationsRequest($status, $from, $to, $page_no, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentsForOrganizations'
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConsentsForOrganizationsRequest($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {

        $resourcePath = '/v1/consents/organizations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }
        // query params
        if ($page_no !== null) {
            if('form' === 'form' && is_array($page_no)) {
                foreach($page_no as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pageNo'] = $page_no;
            }
        }
        // query params
        if ($page_size !== null) {
            if('form' === 'form' && is_array($page_size)) {
                foreach($page_size as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pageSize'] = $page_size;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConsentsSentToIndividuals
     *
     * Get the list of Consents Sent to Individuals.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\UserDataConsentInfoDtoPaginatedList|object
     */
    public function getConsentsSentToIndividuals($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {
        list($response) = $this->getConsentsSentToIndividualsWithHttpInfo($status, $from, $to, $page_no, $page_size);
        return $response;
    }

    /**
     * Operation getConsentsSentToIndividualsWithHttpInfo
     *
     * Get the list of Consents Sent to Individuals.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\UserDataConsentInfoDtoPaginatedList|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConsentsSentToIndividualsWithHttpInfo($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {
        $request = $this->getConsentsSentToIndividualsRequest($status, $from, $to, $page_no, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\UserDataConsentInfoDtoPaginatedList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\UserDataConsentInfoDtoPaginatedList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\UserDataConsentInfoDtoPaginatedList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\UserDataConsentInfoDtoPaginatedList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConsentsSentToIndividualsAsync
     *
     * Get the list of Consents Sent to Individuals.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentsSentToIndividualsAsync($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {
        return $this->getConsentsSentToIndividualsAsyncWithHttpInfo($status, $from, $to, $page_no, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConsentsSentToIndividualsAsyncWithHttpInfo
     *
     * Get the list of Consents Sent to Individuals.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConsentsSentToIndividualsAsyncWithHttpInfo($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {
        $returnType = '\MyDataMyConsent\Model\UserDataConsentInfoDtoPaginatedList';
        $request = $this->getConsentsSentToIndividualsRequest($status, $from, $to, $page_no, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConsentsSentToIndividuals'
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status Data consent status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $from From date time in utc timezone. (optional)
     * @param  \DateTime $to Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConsentsSentToIndividualsRequest($status = null, $from = null, $to = null, $page_no = 1, $page_size = 25)
    {

        $resourcePath = '/v1/consents/individuals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }
        // query params
        if ($page_no !== null) {
            if('form' === 'form' && is_array($page_no)) {
                foreach($page_no as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pageNo'] = $page_no;
            }
        }
        // query params
        if ($page_size !== null) {
            if('form' === 'form' && is_array($page_size)) {
                foreach($page_size as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pageSize'] = $page_size;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrgConsentedAccountTransactions
     *
     * Get organization consented financial account transactions of an individual based on accountId.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\OrganizationFinancialTransactionsDtoPaginatedList|object
     */
    public function getOrgConsentedAccountTransactions($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 1, $page_size = 25)
    {
        list($response) = $this->getOrgConsentedAccountTransactionsWithHttpInfo($consent_id, $account_id, $filters, $from_date_time_utc, $to_date_time_utc, $page_no, $page_size);
        return $response;
    }

    /**
     * Operation getOrgConsentedAccountTransactionsWithHttpInfo
     *
     * Get organization consented financial account transactions of an individual based on accountId.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\OrganizationFinancialTransactionsDtoPaginatedList|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrgConsentedAccountTransactionsWithHttpInfo($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 1, $page_size = 25)
    {
        $request = $this->getOrgConsentedAccountTransactionsRequest($consent_id, $account_id, $filters, $from_date_time_utc, $to_date_time_utc, $page_no, $page_size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\OrganizationFinancialTransactionsDtoPaginatedList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\OrganizationFinancialTransactionsDtoPaginatedList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\OrganizationFinancialTransactionsDtoPaginatedList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\OrganizationFinancialTransactionsDtoPaginatedList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrgConsentedAccountTransactionsAsync
     *
     * Get organization consented financial account transactions of an individual based on accountId.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrgConsentedAccountTransactionsAsync($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 1, $page_size = 25)
    {
        return $this->getOrgConsentedAccountTransactionsAsyncWithHttpInfo($consent_id, $account_id, $filters, $from_date_time_utc, $to_date_time_utc, $page_no, $page_size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrgConsentedAccountTransactionsAsyncWithHttpInfo
     *
     * Get organization consented financial account transactions of an individual based on accountId.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrgConsentedAccountTransactionsAsyncWithHttpInfo($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 1, $page_size = 25)
    {
        $returnType = '\MyDataMyConsent\Model\OrganizationFinancialTransactionsDtoPaginatedList';
        $request = $this->getOrgConsentedAccountTransactionsRequest($consent_id, $account_id, $filters, $from_date_time_utc, $to_date_time_utc, $page_no, $page_size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrgConsentedAccountTransactions'
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $account_id Account id. (required)
     * @param  string $filters Filters. (optional)
     * @param  \DateTime $from_date_time_utc From date time in utc timezone. (optional)
     * @param  \DateTime $to_date_time_utc Til date time in utc timezone. (optional)
     * @param  int $page_no Page number. (optional, default to 1)
     * @param  int $page_size Number of items to return. (optional, default to 25)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrgConsentedAccountTransactionsRequest($consent_id, $account_id, $filters = null, $from_date_time_utc = null, $to_date_time_utc = null, $page_no = 1, $page_size = 25)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getOrgConsentedAccountTransactions'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling getOrgConsentedAccountTransactions'
            );
        }

        $resourcePath = '/v1/consents/organizations/{consentId}/accounts/{accountId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filters !== null) {
            if('form' === 'form' && is_array($filters)) {
                foreach($filters as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filters'] = $filters;
            }
        }
        // query params
        if ($from_date_time_utc !== null) {
            if('form' === 'form' && is_array($from_date_time_utc)) {
                foreach($from_date_time_utc as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fromDateTimeUtc'] = $from_date_time_utc;
            }
        }
        // query params
        if ($to_date_time_utc !== null) {
            if('form' === 'form' && is_array($to_date_time_utc)) {
                foreach($to_date_time_utc as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['toDateTimeUtc'] = $to_date_time_utc;
            }
        }
        // query params
        if ($page_no !== null) {
            if('form' === 'form' && is_array($page_no)) {
                foreach($page_no as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pageNo'] = $page_no;
            }
        }
        // query params
        if ($page_size !== null) {
            if('form' === 'form' && is_array($page_size)) {
                foreach($page_size as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['pageSize'] = $page_size;
            }
        }


        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationConsentDetailsById
     *
     * Get all organization consent details by consent id.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\DataConsentDetailsDto|object
     */
    public function getOrganizationConsentDetailsById($consent_id)
    {
        list($response) = $this->getOrganizationConsentDetailsByIdWithHttpInfo($consent_id);
        return $response;
    }

    /**
     * Operation getOrganizationConsentDetailsByIdWithHttpInfo
     *
     * Get all organization consent details by consent id.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\DataConsentDetailsDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationConsentDetailsByIdWithHttpInfo($consent_id)
    {
        $request = $this->getOrganizationConsentDetailsByIdRequest($consent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\DataConsentDetailsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\DataConsentDetailsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\DataConsentDetailsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\DataConsentDetailsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationConsentDetailsByIdAsync
     *
     * Get all organization consent details by consent id.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationConsentDetailsByIdAsync($consent_id)
    {
        return $this->getOrganizationConsentDetailsByIdAsyncWithHttpInfo($consent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationConsentDetailsByIdAsyncWithHttpInfo
     *
     * Get all organization consent details by consent id.
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationConsentDetailsByIdAsyncWithHttpInfo($consent_id)
    {
        $returnType = '\MyDataMyConsent\Model\DataConsentDetailsDto';
        $request = $this->getOrganizationConsentDetailsByIdRequest($consent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationConsentDetailsById'
     *
     * @param  string $consent_id Consent id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationConsentDetailsByIdRequest($consent_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getOrganizationConsentDetailsById'
            );
        }

        $resourcePath = '/v1/consents/organizations/{consentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationConsentedDocumentById
     *
     * Get organization consent document based on document id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MyDataMyConsent\Model\OrganizationDocumentDetailsDto|object
     */
    public function getOrganizationConsentedDocumentById($consent_id, $document_id)
    {
        list($response) = $this->getOrganizationConsentedDocumentByIdWithHttpInfo($consent_id, $document_id);
        return $response;
    }

    /**
     * Operation getOrganizationConsentedDocumentByIdWithHttpInfo
     *
     * Get organization consent document based on document id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MyDataMyConsent\Model\OrganizationDocumentDetailsDto|object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationConsentedDocumentByIdWithHttpInfo($consent_id, $document_id)
    {
        $request = $this->getOrganizationConsentedDocumentByIdRequest($consent_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MyDataMyConsent\Model\OrganizationDocumentDetailsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\OrganizationDocumentDetailsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MyDataMyConsent\Model\OrganizationDocumentDetailsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\OrganizationDocumentDetailsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationConsentedDocumentByIdAsync
     *
     * Get organization consent document based on document id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationConsentedDocumentByIdAsync($consent_id, $document_id)
    {
        return $this->getOrganizationConsentedDocumentByIdAsyncWithHttpInfo($consent_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationConsentedDocumentByIdAsyncWithHttpInfo
     *
     * Get organization consent document based on document id.
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationConsentedDocumentByIdAsyncWithHttpInfo($consent_id, $document_id)
    {
        $returnType = '\MyDataMyConsent\Model\OrganizationDocumentDetailsDto';
        $request = $this->getOrganizationConsentedDocumentByIdRequest($consent_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationConsentedDocumentById'
     *
     * @param  string $consent_id Consent id. (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getOrganizationConsentedDocumentByIdRequest($consent_id, $document_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling getOrganizationConsentedDocumentById'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling getOrganizationConsentedDocumentById'
            );
        }

        $resourcePath = '/v1/consents/organizations/{consentId}/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
