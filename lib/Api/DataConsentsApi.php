<?php
/**
 * DataConsentsApi
 * PHP version 7.3
 *
 * @category Class
 * @package  MyDataMyConsent
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * My Data My Consent - Developer API
 *
 * Unleashing the power of data consent by establishing trust. The Platform Core Developer API defines a set of capabilities that can be used to request, issue, manage and update data, documents and credentials by organizations. The API can be used to request, manage and update Decentralised Identifiers, Financial Data, Health Data issue Documents, Credentials directly or using OpenID Connect flows, and verify Messages signed with DIDs and much more.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@mydatamyconsent.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MyDataMyConsent\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MyDataMyConsent\ApiException;
use MyDataMyConsent\Configuration;
use MyDataMyConsent\HeaderSelector;
use MyDataMyConsent\ObjectSerializer;

/**
 * DataConsentsApi Class Doc Comment
 *
 * @category Class
 * @package  MyDataMyConsent
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DataConsentsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdGet
     *
     * Get consented financial account details.
     *
     * @param  string $consent_id consent_id (required)
     * @param  string $account_id account_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsConsentIdAccountsAccountIdGet($consent_id, $account_id)
    {
        list($response) = $this->v1ConsentsConsentIdAccountsAccountIdGetWithHttpInfo($consent_id, $account_id);
        return $response;
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdGetWithHttpInfo
     *
     * Get consented financial account details.
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsConsentIdAccountsAccountIdGetWithHttpInfo($consent_id, $account_id)
    {
        $request = $this->v1ConsentsConsentIdAccountsAccountIdGetRequest($consent_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdGetAsync
     *
     * Get consented financial account details.
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdAccountsAccountIdGetAsync($consent_id, $account_id)
    {
        return $this->v1ConsentsConsentIdAccountsAccountIdGetAsyncWithHttpInfo($consent_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdGetAsyncWithHttpInfo
     *
     * Get consented financial account details.
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdAccountsAccountIdGetAsyncWithHttpInfo($consent_id, $account_id)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsConsentIdAccountsAccountIdGetRequest($consent_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsConsentIdAccountsAccountIdGet'
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsConsentIdAccountsAccountIdGetRequest($consent_id, $account_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling v1ConsentsConsentIdAccountsAccountIdGet'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling v1ConsentsConsentIdAccountsAccountIdGet'
            );
        }

        $resourcePath = '/v1/consents/{consentId}/accounts/{accountId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdInsightsGet
     *
     * Get consented financial account insights.
     *
     * @param  string $consent_id consent_id (required)
     * @param  string $account_id account_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsConsentIdAccountsAccountIdInsightsGet($consent_id, $account_id)
    {
        list($response) = $this->v1ConsentsConsentIdAccountsAccountIdInsightsGetWithHttpInfo($consent_id, $account_id);
        return $response;
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdInsightsGetWithHttpInfo
     *
     * Get consented financial account insights.
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsConsentIdAccountsAccountIdInsightsGetWithHttpInfo($consent_id, $account_id)
    {
        $request = $this->v1ConsentsConsentIdAccountsAccountIdInsightsGetRequest($consent_id, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdInsightsGetAsync
     *
     * Get consented financial account insights.
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdAccountsAccountIdInsightsGetAsync($consent_id, $account_id)
    {
        return $this->v1ConsentsConsentIdAccountsAccountIdInsightsGetAsyncWithHttpInfo($consent_id, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdInsightsGetAsyncWithHttpInfo
     *
     * Get consented financial account insights.
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdAccountsAccountIdInsightsGetAsyncWithHttpInfo($consent_id, $account_id)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsConsentIdAccountsAccountIdInsightsGetRequest($consent_id, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsConsentIdAccountsAccountIdInsightsGet'
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsConsentIdAccountsAccountIdInsightsGetRequest($consent_id, $account_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling v1ConsentsConsentIdAccountsAccountIdInsightsGet'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling v1ConsentsConsentIdAccountsAccountIdInsightsGet'
            );
        }

        $resourcePath = '/v1/consents/{consentId}/accounts/{accountId}/insights';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdTransactionsGet
     *
     * Get consented financial account transactions.
     *
     * @param  string $consent_id consent_id (required)
     * @param  string $account_id account_id (required)
     * @param  string $filters filters (optional)
     * @param  \DateTime $from_date from_date (optional)
     * @param  \DateTime $to_date to_date (optional)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsConsentIdAccountsAccountIdTransactionsGet($consent_id, $account_id, $filters = null, $from_date = null, $to_date = null)
    {
        list($response) = $this->v1ConsentsConsentIdAccountsAccountIdTransactionsGetWithHttpInfo($consent_id, $account_id, $filters, $from_date, $to_date);
        return $response;
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdTransactionsGetWithHttpInfo
     *
     * Get consented financial account transactions.
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     * @param  string $filters (optional)
     * @param  \DateTime $from_date (optional)
     * @param  \DateTime $to_date (optional)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsConsentIdAccountsAccountIdTransactionsGetWithHttpInfo($consent_id, $account_id, $filters = null, $from_date = null, $to_date = null)
    {
        $request = $this->v1ConsentsConsentIdAccountsAccountIdTransactionsGetRequest($consent_id, $account_id, $filters, $from_date, $to_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdTransactionsGetAsync
     *
     * Get consented financial account transactions.
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     * @param  string $filters (optional)
     * @param  \DateTime $from_date (optional)
     * @param  \DateTime $to_date (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdAccountsAccountIdTransactionsGetAsync($consent_id, $account_id, $filters = null, $from_date = null, $to_date = null)
    {
        return $this->v1ConsentsConsentIdAccountsAccountIdTransactionsGetAsyncWithHttpInfo($consent_id, $account_id, $filters, $from_date, $to_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsConsentIdAccountsAccountIdTransactionsGetAsyncWithHttpInfo
     *
     * Get consented financial account transactions.
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     * @param  string $filters (optional)
     * @param  \DateTime $from_date (optional)
     * @param  \DateTime $to_date (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdAccountsAccountIdTransactionsGetAsyncWithHttpInfo($consent_id, $account_id, $filters = null, $from_date = null, $to_date = null)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsConsentIdAccountsAccountIdTransactionsGetRequest($consent_id, $account_id, $filters, $from_date, $to_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsConsentIdAccountsAccountIdTransactionsGet'
     *
     * @param  string $consent_id (required)
     * @param  string $account_id (required)
     * @param  string $filters (optional)
     * @param  \DateTime $from_date (optional)
     * @param  \DateTime $to_date (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsConsentIdAccountsAccountIdTransactionsGetRequest($consent_id, $account_id, $filters = null, $from_date = null, $to_date = null)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling v1ConsentsConsentIdAccountsAccountIdTransactionsGet'
            );
        }
        // verify the required parameter 'account_id' is set
        if ($account_id === null || (is_array($account_id) && count($account_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $account_id when calling v1ConsentsConsentIdAccountsAccountIdTransactionsGet'
            );
        }

        $resourcePath = '/v1/consents/{consentId}/accounts/{accountId}/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($filters !== null) {
            if('form' === 'form' && is_array($filters)) {
                foreach($filters as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['filters'] = $filters;
            }
        }
        // query params
        if ($from_date !== null) {
            if('form' === 'form' && is_array($from_date)) {
                foreach($from_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fromDate'] = $from_date;
            }
        }
        // query params
        if ($to_date !== null) {
            if('form' === 'form' && is_array($to_date)) {
                foreach($to_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['toDate'] = $to_date;
            }
        }


        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($account_id !== null) {
            $resourcePath = str_replace(
                '{' . 'accountId' . '}',
                ObjectSerializer::toPathValue($account_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1ConsentsConsentIdAccountsGet
     *
     * Get all accounts in a consent.
     *
     * @param  string $consent_id consent_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsConsentIdAccountsGet($consent_id)
    {
        list($response) = $this->v1ConsentsConsentIdAccountsGetWithHttpInfo($consent_id);
        return $response;
    }

    /**
     * Operation v1ConsentsConsentIdAccountsGetWithHttpInfo
     *
     * Get all accounts in a consent.
     *
     * @param  string $consent_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsConsentIdAccountsGetWithHttpInfo($consent_id)
    {
        $request = $this->v1ConsentsConsentIdAccountsGetRequest($consent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsConsentIdAccountsGetAsync
     *
     * Get all accounts in a consent.
     *
     * @param  string $consent_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdAccountsGetAsync($consent_id)
    {
        return $this->v1ConsentsConsentIdAccountsGetAsyncWithHttpInfo($consent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsConsentIdAccountsGetAsyncWithHttpInfo
     *
     * Get all accounts in a consent.
     *
     * @param  string $consent_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdAccountsGetAsyncWithHttpInfo($consent_id)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsConsentIdAccountsGetRequest($consent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsConsentIdAccountsGet'
     *
     * @param  string $consent_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsConsentIdAccountsGetRequest($consent_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling v1ConsentsConsentIdAccountsGet'
            );
        }

        $resourcePath = '/v1/consents/{consentId}/accounts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet
     *
     * Get analysis of a consented document.
     *
     * @param  string $consent_id consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet($consent_id, $document_id)
    {
        list($response) = $this->v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetWithHttpInfo($consent_id, $document_id);
        return $response;
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetWithHttpInfo
     *
     * Get analysis of a consented document.
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetWithHttpInfo($consent_id, $document_id)
    {
        $request = $this->v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetRequest($consent_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetAsync
     *
     * Get analysis of a consented document.
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetAsync($consent_id, $document_id)
    {
        return $this->v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetAsyncWithHttpInfo($consent_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetAsyncWithHttpInfo
     *
     * Get analysis of a consented document.
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetAsyncWithHttpInfo($consent_id, $document_id)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetRequest($consent_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet'
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdAnalysisGetRequest($consent_id, $document_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling v1ConsentsConsentIdDocumentsDocumentIdAnalysisGet'
            );
        }

        $resourcePath = '/v1/consents/{consentId}/documents/{documentId}/analysis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdDownloadGet
     *
     * Download a consented document.
     *
     * @param  string $consent_id consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdDownloadGet($consent_id, $document_id)
    {
        list($response) = $this->v1ConsentsConsentIdDocumentsDocumentIdDownloadGetWithHttpInfo($consent_id, $document_id);
        return $response;
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdDownloadGetWithHttpInfo
     *
     * Download a consented document.
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdDownloadGetWithHttpInfo($consent_id, $document_id)
    {
        $request = $this->v1ConsentsConsentIdDocumentsDocumentIdDownloadGetRequest($consent_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdDownloadGetAsync
     *
     * Download a consented document.
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdDownloadGetAsync($consent_id, $document_id)
    {
        return $this->v1ConsentsConsentIdDocumentsDocumentIdDownloadGetAsyncWithHttpInfo($consent_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdDownloadGetAsyncWithHttpInfo
     *
     * Download a consented document.
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdDownloadGetAsyncWithHttpInfo($consent_id, $document_id)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsConsentIdDocumentsDocumentIdDownloadGetRequest($consent_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsConsentIdDocumentsDocumentIdDownloadGet'
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdDownloadGetRequest($consent_id, $document_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling v1ConsentsConsentIdDocumentsDocumentIdDownloadGet'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling v1ConsentsConsentIdDocumentsDocumentIdDownloadGet'
            );
        }

        $resourcePath = '/v1/consents/{consentId}/documents/{documentId}/download';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdGet
     *
     * Get consented document details.
     *
     * @param  string $consent_id consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdGet($consent_id, $document_id)
    {
        list($response) = $this->v1ConsentsConsentIdDocumentsDocumentIdGetWithHttpInfo($consent_id, $document_id);
        return $response;
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdGetWithHttpInfo
     *
     * Get consented document details.
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdGetWithHttpInfo($consent_id, $document_id)
    {
        $request = $this->v1ConsentsConsentIdDocumentsDocumentIdGetRequest($consent_id, $document_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdGetAsync
     *
     * Get consented document details.
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdGetAsync($consent_id, $document_id)
    {
        return $this->v1ConsentsConsentIdDocumentsDocumentIdGetAsyncWithHttpInfo($consent_id, $document_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsDocumentIdGetAsyncWithHttpInfo
     *
     * Get consented document details.
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdGetAsyncWithHttpInfo($consent_id, $document_id)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsConsentIdDocumentsDocumentIdGetRequest($consent_id, $document_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsConsentIdDocumentsDocumentIdGet'
     *
     * @param  string $consent_id (required)
     * @param  string $document_id Document Id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsConsentIdDocumentsDocumentIdGetRequest($consent_id, $document_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling v1ConsentsConsentIdDocumentsDocumentIdGet'
            );
        }
        // verify the required parameter 'document_id' is set
        if ($document_id === null || (is_array($document_id) && count($document_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_id when calling v1ConsentsConsentIdDocumentsDocumentIdGet'
            );
        }

        $resourcePath = '/v1/consents/{consentId}/documents/{documentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }
        // path params
        if ($document_id !== null) {
            $resourcePath = str_replace(
                '{' . 'documentId' . '}',
                ObjectSerializer::toPathValue($document_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsGet
     *
     * Get all documents in a consent.
     *
     * @param  string $consent_id consent_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsConsentIdDocumentsGet($consent_id)
    {
        list($response) = $this->v1ConsentsConsentIdDocumentsGetWithHttpInfo($consent_id);
        return $response;
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsGetWithHttpInfo
     *
     * Get all documents in a consent.
     *
     * @param  string $consent_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsConsentIdDocumentsGetWithHttpInfo($consent_id)
    {
        $request = $this->v1ConsentsConsentIdDocumentsGetRequest($consent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsGetAsync
     *
     * Get all documents in a consent.
     *
     * @param  string $consent_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdDocumentsGetAsync($consent_id)
    {
        return $this->v1ConsentsConsentIdDocumentsGetAsyncWithHttpInfo($consent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsConsentIdDocumentsGetAsyncWithHttpInfo
     *
     * Get all documents in a consent.
     *
     * @param  string $consent_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdDocumentsGetAsyncWithHttpInfo($consent_id)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsConsentIdDocumentsGetRequest($consent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsConsentIdDocumentsGet'
     *
     * @param  string $consent_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsConsentIdDocumentsGetRequest($consent_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling v1ConsentsConsentIdDocumentsGet'
            );
        }

        $resourcePath = '/v1/consents/{consentId}/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1ConsentsConsentIdGet
     *
     * Get consent details by consent id.
     *
     * @param  string $consent_id consent_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsConsentIdGet($consent_id)
    {
        list($response) = $this->v1ConsentsConsentIdGetWithHttpInfo($consent_id);
        return $response;
    }

    /**
     * Operation v1ConsentsConsentIdGetWithHttpInfo
     *
     * Get consent details by consent id.
     *
     * @param  string $consent_id (required)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsConsentIdGetWithHttpInfo($consent_id)
    {
        $request = $this->v1ConsentsConsentIdGetRequest($consent_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsConsentIdGetAsync
     *
     * Get consent details by consent id.
     *
     * @param  string $consent_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdGetAsync($consent_id)
    {
        return $this->v1ConsentsConsentIdGetAsyncWithHttpInfo($consent_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsConsentIdGetAsyncWithHttpInfo
     *
     * Get consent details by consent id.
     *
     * @param  string $consent_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsConsentIdGetAsyncWithHttpInfo($consent_id)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsConsentIdGetRequest($consent_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsConsentIdGet'
     *
     * @param  string $consent_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsConsentIdGetRequest($consent_id)
    {
        // verify the required parameter 'consent_id' is set
        if ($consent_id === null || (is_array($consent_id) && count($consent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $consent_id when calling v1ConsentsConsentIdGet'
            );
        }

        $resourcePath = '/v1/consents/{consentId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($consent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'consentId' . '}',
                ObjectSerializer::toPathValue($consent_id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v1ConsentsGet
     *
     * Get all consents filtered by status and time.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $start_date System.DateTime. (optional)
     * @param  \DateTime $end_date till dateSystem.DateTime. (optional)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\MyDataMyConsent\Model\ProblemDetails
     */
    public function v1ConsentsGet($status = null, $start_date = null, $end_date = null)
    {
        list($response) = $this->v1ConsentsGetWithHttpInfo($status, $start_date, $end_date);
        return $response;
    }

    /**
     * Operation v1ConsentsGetWithHttpInfo
     *
     * Get all consents filtered by status and time.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $start_date System.DateTime. (optional)
     * @param  \DateTime $end_date till dateSystem.DateTime. (optional)
     *
     * @throws \MyDataMyConsent\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\MyDataMyConsent\Model\ProblemDetails, HTTP status code, HTTP response headers (array of strings)
     */
    public function v1ConsentsGetWithHttpInfo($status = null, $start_date = null, $end_date = null)
    {
        $request = $this->v1ConsentsGetRequest($status, $start_date, $end_date);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                default:
                    if ('\MyDataMyConsent\Model\ProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MyDataMyConsent\Model\ProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                default:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MyDataMyConsent\Model\ProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v1ConsentsGetAsync
     *
     * Get all consents filtered by status and time.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $start_date System.DateTime. (optional)
     * @param  \DateTime $end_date till dateSystem.DateTime. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsGetAsync($status = null, $start_date = null, $end_date = null)
    {
        return $this->v1ConsentsGetAsyncWithHttpInfo($status, $start_date, $end_date)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v1ConsentsGetAsyncWithHttpInfo
     *
     * Get all consents filtered by status and time.
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $start_date System.DateTime. (optional)
     * @param  \DateTime $end_date till dateSystem.DateTime. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v1ConsentsGetAsyncWithHttpInfo($status = null, $start_date = null, $end_date = null)
    {
        $returnType = 'object';
        $request = $this->v1ConsentsGetRequest($status, $start_date, $end_date);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v1ConsentsGet'
     *
     * @param  \MyDataMyConsent\Model\DataConsentStatus $status MyDataMyConsent.Domain.Entities.ConsentAggregate.Enums.DataConsentStatus. (optional)
     * @param  \DateTime $start_date System.DateTime. (optional)
     * @param  \DateTime $end_date till dateSystem.DateTime. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v1ConsentsGetRequest($status = null, $start_date = null, $end_date = null)
    {

        $resourcePath = '/v1/consents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
